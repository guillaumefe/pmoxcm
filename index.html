<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PMO XCM</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f5f5f5;
        }
        .container {
            width: 90%;
            max-width: 800px;
            background: #fff;
            padding: 20px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            overflow: auto;
            height: 90vh;
        }
        header {
            margin-bottom: 20px;
        }
        header h1 {
            margin: 0;
            font-size: 1.5em;
        }
        section {
            margin-bottom: 20px;
        }
        form {
            display: flex;
            flex-direction: column;
        }
        form label {
            margin-bottom: 5px;
        }
        form input, form select, form button, form textarea {
            margin-bottom: 10px;
            padding: 10px;
            font-size: 1em;
        }
        textarea {
            resize: vertical;
            height: 34px;
        }
        button {
            padding: 10px;
            background: #007BFF;
            color: #fff;
            border: none;
            cursor: pointer;
            font-size: 1em;
        }
        button:hover {
            background: #0056b3;
        }
        .clear-form-button {
            background: #f0f0f0;
            color: #000;
        }
        .clear-form-button:hover {
    background-color: #333; /* Gris fonc√© */
    color: #fff; /* Police blanche */
}
        .error-message, .progress-message {
            text-align: center;
            font-weight: bold;
        }
        .error-message {
            color: red;
        }
        .progress-message {
            color: orange;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-radius: 50%;
            border-top: 4px solid #3498db;
            width: 30px;
            height: 30px;
            animation: spin 2s linear infinite;
            display: none;
            margin: 0 auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .result-container {
            margin-top: 20px;
        }
        .result-container h3 {
            margin-top: 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        table, th, td {
            border: 1px solid #ddd;
        }
        th, td {
            padding: 8px;
            text-align: left;
            vertical-align: top;
        }
        th {
            background-color: #f2f2f2;
        }
        td {
            max-height: 70px;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            max-width: 100px;
        }
        .added-row-table {
            position: relative;
            margin-bottom: 20px;
        }
        .edit-btn, .delete-btn, .view-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            color: #007BFF;
        }
        .edit-btn:hover, .delete-btn:hover, .view-btn:hover {
            color: #d9534f;
        }
        .loading-indicator {
            display: none;
            text-align: center;
            color: #007BFF;
            font-weight: bold;
        }
        #downloadLink {
            display: block;
            margin: 10px 0;
            color: #007BFF;
            text-decoration: underline;
            cursor: pointer;
        }
        .tab {
            overflow: hidden;
            border-bottom: 1px solid #ccc;
            background-color: #f1f1f1;
        }
        .tab button {
            background-color: inherit;
            float: left;
            border: none;
            outline: none;
            cursor: pointer;
            padding: 8px 12px;
            transition: 0.3s;
            font-size: 17px;
            color: #000;
        }
        .tab button:hover {
            background-color: #ddd;
        }
        .tab button.active {
            background-color: #ccc;
        }
        .tabcontent {
            display: none;
            padding: 6px 12px;
            border-top: none;
        }

.form-inline {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    align-items: center;
}

.form-inline label {
    flex: 1;
    min-width: 100px;
}

.form-inline input {
    flex: 2;
    min-width: 150px;
    max-width: 100%;
    box-sizing: border-box;
}
        .search-table {
            width: 100%;
        }
        .search-table td {
            padding: 5px;
        }
        .popup {
            display: none;
            position: fixed;
            top: 5%;
            left: 5%;
            width: 90%;
            height: 90%;
            background-color: #fff;
            border: 1px solid #ccc;
            padding: 20px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
            z-index: 1000;
        }
        .popup h2 {
            margin-top: 0;
        }
        .popup button {
            margin-top: 10px;
        }
        .overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
        }
        .centered-button {
            display: block;
            margin: 10px auto;
            font-size: 0.8em;
            padding: 5px 10px;
        }
        .button-container {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }
        .button-container button {
    flex: 1;
}

#submitEditButton {
    display: none; /* On le cache par d√©faut */
    flex: 1; /* Pour qu'il prenne la m√™me place que les autres boutons */
}
        hr {
            border: 0;
            height: 1px;
            background: #ccc;
            margin-bottom: 20px;
            display: none;
        }

label[for="searchMode"] {
    cursor: pointer;
}
.toggle-btn {
    padding: 10px;
    background: #007BFF;
    color: #fff;
    border: none;
    cursor: pointer;
    font-size: 1em;
    margin-bottom: 10px;
}

.toggle-btn:hover {
    background: #0056b3;
}

.title-row,
.search-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.filter-input {
    padding: 5px;
    font-size: 1em;
}

.progress-message {
    text-align: center;
    font-weight: bold;
    color: orange;
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background-color: #fff;
    padding: 10px;
    border: 1px solid orange;
    border-radius: 5px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    z-index: 1000;
}
        
.progress-message.error {
    color: red;
    border: 1px solid red;
}
        
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>PMO Excel Manager</h1>
        </header>
        <p><i>This is a prototype, and to simplify it, we would need the intervention of Active Directory administrators, which is quite complex. If the solution convinces, we can work with the administrators to make the entire process more streamlined and less manual.</i></p>
        <section id="downloadSection">
            <h2>Select a File to Use</h2>
            <form id="downloadForm">
                <label for="fileSelect">File:</label>
                <select id="fileSelect"></select>
                <span id="downloadLink">Download a fresh version of the selected file</span>
            </form>
        </section>
        <section id="confirmDownloadSection">
            <button id="confirmDownloadButton">I have downloaded the file</button>
        </section>
        <section id="uploadSection" style="display: none;">
            <h2>Load the Downloaded File</h2>
            <input type="file" id="fileInput" accept=".xlsx,.xlsm">
            <button id="fileSubmit" disabled style="font-size: 0.8em; padding: 5px;">Load</button>
            <div id="loader" class="loader"></div>
        </section>
        <section id="sheetSelectionSection" style="display: none;">
            <h2>Select a Sheet</h2>
            <form id="sheetSelectionForm">
                <label for="sheetSelect">Sheet:</label>
                <select id="sheetSelect"></select>
                <button type="submit">Load Sheet</button>
            </form>
        </section>
        <div id="tabSection" class="tab" style="display: none;">
            <button class="tablinks active" onclick="openTab(event, 'AddRow')">Add a New Row</button>
            <button class="tablinks" onclick="openTab(event, 'Search')">Search</button>
        </div>
<section id="AddRow" class="tabcontent" style="display: none;">
    <div class="title-row">
        <h2>Add a New Row</h2>
        <input type="text" id="addRowFilter" placeholder="Filter fields..." class="filter-input">
    </div>
    <form id="dynamicForm">
        <button type="button" id="clearFormButton" class="clear-form-button">Clear Form</button>
        <button type="submit">Add Row</button>
    </form>
    <div id="loadingIndicator" class="loading-indicator">Adding row...</div>
</section>

<section id="Search" class="tabcontent" style="display: none;">
    <h2>Search and Edit</h2>
    <div class="search-row">
        <label for="searchMode">Search Mode:</label>
        <button id="searchMode" class="toggle-btn">AND</button>
        <input type="text" id="searchFilter" placeholder="Filter columns..." class="filter-input">
    </div>
    <p>Use && for AND, || for OR, and ! for NOT.</p>
    <p><i>Example: "apple && orange" will find rows containing both "apple" and "orange". "apple || orange" will find rows containing either "apple" or "orange". "!apple" will find rows that do not contain "apple".</i></p>
    <form id="searchForm" class="form-inline">
        <table class="search-table">
            <tbody id="searchInputs"></tbody>
        </table>
        <label for="restrictSearch"><input type="checkbox" id="restrictSearch"> Restrict search to all keywords</label>
        <button type="submit">Search</button>
    </form>
</section>

        <div id="results" class="result-container" style="display: none;">
            <h3>Search Results</h3>
            <form id="editForm"></form>
            <div id="searchLoader" class="loader" style="display: none;"></div>
        </div>
        <div id="messageContainer" class="error-message" style="display: none;"></div>
        <hr id="summarySeparator">
<section id="summarySection" style="display: none;">
    <h2>Summary of the modifications to be sent to PMO for validation</h2>
    <div id="addedRowsContainer" style="display: none;">
        <h3>Additions</h3>
        <div id="addedRows"></div>
    </div>
    <div id="modifiedRowsContainer" style="display: none;">
        <h3>Modifications</h3>
        <div id="modifiedRows"></div>
    </div>
    <button id="generateFile">Generate Email</button>
    <div id="emailContentContainer" style="display: none;">
        <button id="copyEmailContent" style="float: right;">Copy</button>
        <pre id="emailContent"></pre>
    </div>
</section>
        <div id="progressContainer" class="progress-message" style="display: none;">
            <span id="progressMessage"></span>
            <button id="resetButton" class="centered-button" style="display: none;">Reset Interface</button>
            <button id="closeProgressButton" class="centered-button" style="display: none;margin-left: 10px;">Close</button>
        </div>
        <div class="overlay" id="overlay"></div>
        <div class="popup" id="popup">
          <h2>View Row</h2>
          <form id="popupForm"></form>
          <div class="button-container">
              <button type="button" id="prevRowButton">Previous Row</button>
              <button type="button" id="okButton">Close</button>
              <button type="button" id="editButton">Edit</button>
              <button type="button" id="submitEditButton" style="display: none;">Submit Change</button>
              <button type="button" id="nextRowButton">Next Row</button>
          </div>
      </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.0.0/crypto-js.min.js"></script>
    <script>
        const EMAILS = [];
        const CC_EMAILS = [];

        const EMAIL_TEMPLATE = `
Dear PMO Team,

Some modifications are needed to the file(s): {FILES_LIST}

Summary of the proposed modifications:

{SUMMARY}

Details of the proposed modifications are as follows:

{MODIFICATIONS}

--> Please validate the proposed changes (if you prefer to make the changes yourself, please let us know when it is done)

Further information is available upon request.

Best regards,
`;

        const FILE_OPTIONS = [
          {
            name: "Select a file",
            url: "",
            defaultSheet: "" // Ajouter l'attribut defaultSheet ici
          },
          {
            name: "Consolidated Action Plan",
            url: "",
            defaultSheet: "Consolidated Action Plan" // Ajouter l'attribut defaultSheet ici
          }
        ];



        document.addEventListener('DOMContentLoaded', () => {
    const fileSelect = document.getElementById('fileSelect');
    const downloadLink = document.getElementById('downloadLink');
    const confirmDownloadButton = document.getElementById('confirmDownloadButton');
    const uploadSection = document.getElementById('uploadSection');
    const fileInput = document.getElementById('fileInput');
    const fileSubmit = document.getElementById('fileSubmit');
    const loader = document.getElementById('loader');
    const sheetSelectionSection = document.getElementById('sheetSelectionSection');
    const sheetSelectionForm = document.getElementById('sheetSelectionForm');
    const sheetSelect = document.getElementById('sheetSelect');
    const loadingIndicator = document.getElementById('loadingIndicator');
    const addedRowsContainer = document.getElementById('addedRowsContainer');
    const modifiedRowsContainer = document.getElementById('modifiedRowsContainer');
    const searchForm = document.getElementById('searchForm');
    const restrictSearch = document.getElementById('restrictSearch');
    const results = document.getElementById('results');
    const editForm = document.getElementById('editForm');
    const progressContainer = document.getElementById('progressContainer');
    const progressMessage = document.getElementById('progressMessage');
    const resetButton = document.getElementById('resetButton');
    const closeProgressButton = document.getElementById('closeProgressButton');
    const summarySection = document.getElementById('summarySection');
    const summarySeparator = document.getElementById('summarySeparator');
    const addedRows = document.getElementById('addedRows');
    const modifiedRows = document.getElementById('modifiedRows');
    const tabSection = document.getElementById('tabSection');
    const overlay = document.getElementById('overlay');
    const popup = document.getElementById('popup');
    const popupForm = document.getElementById('popupForm');
    const searchLoader = document.getElementById('searchLoader');
    const prevRowButton = document.getElementById('prevRowButton');
    const nextRowButton = document.getElementById('nextRowButton');
    const editButton = document.getElementById('editButton');
    const okButton = document.getElementById('okButton');
    const submitEditButton = document.getElementById('submitEditButton');
    const clearFormButton = document.getElementById('clearFormButton');
    const messageContainer = document.getElementById('messageContainer');

    let workbook;
    let currentSheetName = '';
    let headers;
    let addedRowsBySheet = {};
    let modifiedRowsBySheet = {};
    let searchResults = [];
    let currentRowIndex = -1;
    let currentFileName = '';
    let modifiedRowHashes = new Map();
    let addedRowsHashes = new Set();
    let initialAddedRows = {}; // Nouveau

    populateFileSelect();
    loadFromLocalStorage(); // Charger les donn√©es depuis le local storage

    const generateFileButton = document.getElementById('generateFile');
    const emailContentContainer = document.getElementById('emailContentContainer');
    const emailContent = document.getElementById('emailContent');
    const copyEmailContentButton = document.getElementById('copyEmailContent');

    const searchFilterInput = document.getElementById('searchFilter');
    const addRowFilterInput = document.getElementById('addRowFilter');
    const searchInputs = document.getElementById('searchInputs');
    const dynamicForm = document.getElementById('dynamicForm');

    generateFileButton.addEventListener('click', generateEmail);
    copyEmailContentButton.addEventListener('click', copyEmailContent);

    fileSelect.addEventListener('change', handleFileSelection);
    downloadLink.addEventListener('click', handleDownloadClick);
    confirmDownloadButton.addEventListener('click', handleConfirmDownload);
    fileInput.addEventListener('change', handleFileChange);
    fileSubmit.addEventListener('click', handleFileSubmit);
    sheetSelectionForm.addEventListener('submit', handleSheetSelection);
    dynamicForm.addEventListener('submit', handleFormSubmit);
    searchForm.addEventListener('submit', handleSearch);
    resetButton.addEventListener('click', resetInterface);
    closeProgressButton.addEventListener('click', () => {
      progressContainer.style.display = 'none';
    });
    overlay.addEventListener('click', closePopup);
    prevRowButton.addEventListener('click', () => navigateRow(-1));
    nextRowButton.addEventListener('click', () => navigateRow(1));
    editButton.addEventListener('click', enableEditing);
    submitEditButton.addEventListener('click', submitEdit);
    clearFormButton.addEventListener('click', clearForm);

    function populateFileSelect() {
        FILE_OPTIONS.forEach(option => {
            const opt = document.createElement('option');
            opt.value = option.url;
            opt.textContent = option.name;
            fileSelect.appendChild(opt);
        });
    }

    function handleFileSelection() {
        const fileUrl = fileSelect.value;
        if (fileUrl) {
            downloadLink.dataset.url = fileUrl;
            downloadLink.style.display = 'block';
        } else {
            downloadLink.style.display = 'none';
        }
        confirmDownloadButton.style.display = fileUrl ? 'block' : 'none';
        uploadSection.style.display = 'none';
        tabSection.style.display = 'none';
        sheetSelectionSection.style.display = 'none';
        resetInterfacePartial();
    }

    function handleDownloadClick() {
        const fileUrl = downloadLink.dataset.url;
        const a = document.createElement('a');
        a.href = fileUrl;
        a.download = fileUrl.split('/').pop();
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    }

    function handleConfirmDownload() {
        confirmDownloadButton.style.display = 'none';
        downloadLink.style.display = 'none';
        uploadSection.style.display = 'block';
    }

    function handleFileChange() {
        if (fileInput.files.length > 0) {
            fileSubmit.disabled = false;
        }
    }

    function handleFileSubmit(event) {
        event.preventDefault();
        if (!fileInput.files.length) {
            showError("Please select a file.");
            return;
        }
        loader.style.display = 'block';
        setTimeout(handleFile, 100);
    }

    function handleFile() {
        const file = fileInput.files[0];
        const reader = new FileReader();
        currentFileName = file.name;
        reader.onload = function (e) {
            try {
                const data = new Uint8Array(e.target.result);
                workbook = XLSX.read(data, { type: 'array' });
                if (workbook.SheetNames.length > 1) {
                    showSheetSelection(workbook.SheetNames);
                } else {
                    currentSheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[currentSheetName];
                    headers = getHeaders(worksheet);
                    createForm(headers);
                    createSearchForm(headers);
                    tabSection.style.display = 'block';
                    document.querySelector(".tab button:first-child").classList.add("active");
                    document.getElementById("AddRow").style.display = 'block';
                }
            } catch (error) {
                showError("Failed to read the file: " + error.message);
            } finally {
                loader.style.display = 'none';
                uploadSection.style.display = 'none';
            }
        };
        reader.readAsArrayBuffer(file);
    }

    function showSheetSelection(sheetNames) {
        sheetSelect.innerHTML = '';
        sheetNames.forEach(name => {
            const option = document.createElement('option');
            option.value = name;
            option.textContent = name;
            sheetSelect.appendChild(option);
        });
        sheetSelectionSection.style.display = 'block';
        tabSection.style.display = 'none';
    }

    function handleFile() {
    const file = fileInput.files[0];
    const reader = new FileReader();
    currentFileName = file.name;
    reader.onload = function (e) {
        try {
            const data = new Uint8Array(e.target.result);
            workbook = XLSX.read(data, { type: 'array' });

            const selectedFile = FILE_OPTIONS.find(option => option.url === fileSelect.value);
            const defaultSheetName = selectedFile.defaultSheet;

            if (workbook.SheetNames.length > 1) {
                showSheetSelection(workbook.SheetNames, defaultSheetName);
            } else {
                currentSheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[currentSheetName];
                headers = getHeaders(worksheet);
                createForm(headers);
                createSearchForm(headers);
                tabSection.style.display = 'block';
                document.querySelector(".tab button:first-child").classList.add("active");
                document.getElementById("AddRow").style.display = 'block';
            }
        } catch (error) {
            showError("Failed to read the file: " + error.message);
        } finally {
            loader.style.display = 'none';
            uploadSection.style.display = 'none';
        }
    };
    reader.readAsArrayBuffer(file);
}

function showSheetSelection(sheetNames, defaultSheetName) {
    sheetSelect.innerHTML = '';
    let defaultIndex = 0;

    sheetNames.forEach((name, index) => {
        const option = document.createElement('option');
        option.value = name;
        option.textContent = name;
        sheetSelect.appendChild(option);

        if (name === defaultSheetName) {
            defaultIndex = index;
        }
    });

    sheetSelect.selectedIndex = defaultIndex;
    sheetSelectionSection.style.display = 'block';
    tabSection.style.display = 'none';
}


    function handleSheetSelection(event) {
        event.preventDefault();
        currentSheetName = sheetSelect.value;
        const worksheet = workbook.Sheets[currentSheetName];
        headers = getHeaders(worksheet);
        createForm(headers);
        createSearchForm(headers);
        tabSection.style.display = 'block';
        openTab(event, 'AddRow');
        clearSearchResults();
    }

    function getHeaders(worksheet) {
        const range = XLSX.utils.decode_range(worksheet['!ref']);
        if (!range || !range.s || !range.e) {
            throw new Error("Invalid range");
        }
        let maxColCount = 0;
        let headerRowIndex = range.s.r;

        for (let rowNum = range.s.r; rowNum <= range.e.r; rowNum++) {
            let colCount = 0;
            for (let colNum = range.s.c; colNum <= range.e.c; colNum++) {
                const cell = worksheet[XLSX.utils.encode_cell({ r: rowNum, c: colNum })];
                if (cell && cell.v) {
                    colCount++;
                }
            }
            if (colCount > maxColCount) {
                maxColCount = colCount;
                headerRowIndex = rowNum;
            }
        }

        const headers = [];
        for (let colNum = range.s.c; colNum <= range.e.c; colNum++) {
            const cell = worksheet[XLSX.utils.encode_cell({ r: headerRowIndex, c: colNum })];
            if (cell && cell.v) {
                headers.push(cell.v);
            }
        }
        return headers;
    }

    function createForm(headers) {
        dynamicForm.innerHTML = '';
        headers.forEach(header => {
            const label = document.createElement('label');
            label.textContent = header;
            const textarea = document.createElement('textarea');
            textarea.name = header;
            textarea.style.height = '34px';
            dynamicForm.appendChild(label);
            dynamicForm.appendChild(textarea);
        });
        const clearButton = document.createElement('button');
        clearButton.type = 'button';
        clearButton.textContent = 'Clear Form';
        clearButton.id = 'clearFormButton';
        clearButton.classList.add('clear-form-button');
        clearButton.addEventListener('click', clearForm);
        dynamicForm.appendChild(clearButton);
        const submitButton = document.createElement('button');
        submitButton.type = 'submit';
        submitButton.textContent = 'Add Row';
        dynamicForm.appendChild(submitButton);
        document.getElementById('AddRow').style.display = 'block';
        clearMessages();
    }

    function createSearchForm(headers) {
        searchInputs.innerHTML = '';
        headers.forEach(header => {
            const row = document.createElement('tr');
            const labelCell = document.createElement('td');
            const inputCell = document.createElement('td');
            const label = document.createElement('label');
            label.textContent = header;
            const input = document.createElement('input');
            input.type = 'text';
            input.name = header;
            labelCell.appendChild(label);
            inputCell.appendChild(input);
            row.appendChild(labelCell);
            row.appendChild(inputCell);
            searchInputs.appendChild(row);
        });
    }

    function handleFormSubmit(event) {
        event.preventDefault();
        const formData = new FormData(dynamicForm);
        const row = {};
        let hasEmptyFields = false;
        headers.forEach(header => {
            const value = formData.get(header);
            if (!value) {
                hasEmptyFields = true;
            }
            row[header] = value;
        });

        if (hasEmptyFields) {
            showError("All fields must be filled out.");
            return;
        }

        loadingIndicator.style.display = 'block';
        showProgress("Adding new row...");
        setTimeout(() => {
            try {
                const rowHash = CryptoJS.MD5(JSON.stringify(row)).toString();
                addedRowsHashes.add(rowHash);

                if (!addedRowsBySheet[currentFileName]) {
                    addedRowsBySheet[currentFileName] = {};
                }
                if (!addedRowsBySheet[currentFileName][currentSheetName]) {
                    addedRowsBySheet[currentFileName][currentSheetName] = {
                        headers: headers,
                        rows: []
                    };
                }
                addedRowsBySheet[currentFileName][currentSheetName].rows.push(row);

                // Stocker la ligne initialement ajout√©e
                if (!initialAddedRows[currentFileName]) {
                    initialAddedRows[currentFileName] = {};
                }
                if (!initialAddedRows[currentFileName][currentSheetName]) {
                    initialAddedRows[currentFileName][currentSheetName] = [];
                }
                initialAddedRows[currentFileName][currentSheetName].push(row);

                updateSummaryDisplay();
                showProgress("Row added successfully.");
                loadingIndicator.style.display = 'none';
            } catch (error) {
                showError("Failed to add the row: " + error.message);
                loadingIndicator.style.display = 'none';
            }
        }, 100);
    }

    function clearForm() {
        const textareas = dynamicForm.querySelectorAll('textarea');
        textareas.forEach(textarea => {
            textarea.value = '';
        });
    }

    function handleSearch(event) {
        event.preventDefault();
        searchLoader.style.display = 'block';
        const formData = new FormData(searchForm);
        const query = {};
        let hasAnyKeyword = false;
        headers.forEach(header => {
            const value = normalizeString(formData.get(header));
            if (value) {
                query[header] = value;
                hasAnyKeyword = true;
            }
        });

        if (!hasAnyKeyword) {
            showError("Please enter at least one keyword.");
            searchLoader.style.display = 'none';
            return;
        }

        showProgress("Starting search...");
        try {
            searchResults = searchRows(query, restrictSearch.checked);
            displayResults(searchResults);
        } catch (error) {
            showError("Failed to search: " + error.message);
        } finally {
            searchLoader.style.display = 'none';
        }
    }

    function searchRows(query, restrict) {
        const worksheet = workbook.Sheets[currentSheetName];
        const range = XLSX.utils.decode_range(worksheet['!ref']);
        const results = [];

        for (let rowNum = range.s.r + 1; rowNum <= range.e.r; rowNum++) {
            let rowMatch = true;
            const row = {};

            headers.forEach((header, index) => {
                const cell = worksheet[XLSX.utils.encode_cell({ r: rowNum, c: index })];
                const cellValue = cell ? normalizeString(cell.v) : '';
                const queryValue = query[header] || '';

                if (queryValue) {
                    const queryParts = queryValue.split(/(&&|\|\||AND|OR|!)/).map(part => part.trim());
                    let operator = null;

                    for (let i = 0; i < queryParts.length; i++) {
                        const part = queryParts[i];
                        if (part === '&&' || part === 'AND') {
                            operator = 'AND';
                        } else if (part === '||' || part === 'OR') {
                            operator = 'OR';
                        } else if (part === '!') {
                            operator = 'NOT';
                        } else {
                            let match;
                            if (operator === 'NOT') {
                                match = !cellValue.includes(part);
                                operator = null;
                            } else {
                                match = cellValue.includes(part);
                            }

                            if (operator === 'AND' && !match) {
                                rowMatch = false;
                            } else if (operator === 'OR' && match) {
                                rowMatch = true;
                            } else if (operator === null) {
                                rowMatch = match;
                            }
                        }
                    }
                }

                row[header] = cell ? cell.v : '';
            });

            if (rowMatch) {
                const rowHash = CryptoJS.MD5(JSON.stringify(row)).toString();
                results.push({ rowNum, row, rowHash });
            }

            if (rowNum % 10 === 0) {
                showProgress(`Processing row ${rowNum}...`);
            }
        }

        return results;
    }

    function displayResults(searchResults) {
        clearMessages();
        results.style.display = 'block';
        editForm.innerHTML = '';

        if (searchResults.length === 0) {
            showError("No results found. Please adjust your keywords and try again.");
            return;
        }

        const table = document.createElement('table');
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        const viewTh = document.createElement('th');
        viewTh.textContent = 'View';
        headerRow.appendChild(viewTh);
        headers.forEach(header => {
            const th = document.createElement('th');
            th.textContent = header;
            headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);
        table.appendChild(thead);

        const tbody = document.createElement('tbody');
        searchResults.forEach(({ rowNum, row, rowHash }, index) => {
            const dataRow = document.createElement('tr');
            dataRow.setAttribute('data-key', rowHash);
            const viewButtonCell = document.createElement('td');
            const viewButton = document.createElement('button');
            viewButton.textContent = 'üëÅ';
            viewButton.classList.add('view-btn');
            viewButton.addEventListener('click', (event) => {
                event.preventDefault();
                openReadOnlyPopup(index, row, rowHash);
            });
            viewButtonCell.appendChild(viewButton);
            dataRow.appendChild(viewButtonCell);
            headers.forEach(header => {
                const td = document.createElement('td');
                td.style.maxHeight = '70px';
                td.style.overflow = 'hidden';
                td.style.whiteSpace = 'nowrap';
                td.style.textOverflow = 'ellipsis';
                td.textContent = row[header] && row[header].length > 100 ? row[header].substring(0, 100) + '...' : row[header];
                dataRow.appendChild(td);
            });
            dataRow.addEventListener('click', (event) => {
                event.preventDefault();
                highlightRow(index);
            });
            tbody.appendChild(dataRow);
        });
        table.appendChild(tbody);
        editForm.appendChild(table);
    }

    function openPopup(rowNum, row, rowHash, isReadOnly = true) {
        popupForm.innerHTML = '';
        const existingEntry = modifiedRowsBySheet[currentFileName]?.[currentSheetName]?.[rowHash];
        const displayRow = existingEntry || row;
        headers.forEach(header => {
            const label = document.createElement('label');
            label.textContent = header;
            const textarea = document.createElement('textarea');
            textarea.name = header;
            textarea.value = displayRow[header] || '';
            textarea.readOnly = isReadOnly;
            popupForm.appendChild(label);
            popupForm.appendChild(textarea);
        });
        popup.dataset.md5 = rowHash;

        editButton.style.display = isReadOnly ? 'block' : 'none';
        submitEditButton.style.display = isReadOnly ? 'none' : 'block';
        prevRowButton.style.display = currentRowIndex > 0 ? 'inline-block' : 'none';
        nextRowButton.style.display = currentRowIndex < searchResults.length - 1 ? 'inline-block' : 'none';
        okButton.style.display = 'block';
        overlay.style.display = 'block';
        popup.style.display = 'block';
        highlightRow(currentRowIndex);
    }

    function openReadOnlyPopup(rowIndex, row, rowHash) {
        currentRowIndex = rowIndex;
        const rowData = getRowData(currentFileName, currentSheetName, rowIndex, row);
        openPopup(rowIndex, rowData, rowHash, true);
    }

    function navigateRow(direction) {
        const newRowIndex = currentRowIndex + direction;
        if (newRowIndex >= 0 && newRowIndex < searchResults.length) {
            if (popupForm.querySelector('textarea[readonly]')) {
                openReadOnlyPopup(newRowIndex, searchResults[newRowIndex].row, searchResults[newRowIndex].rowHash);
            } else {
                if (confirm('You have unsaved changes. Do you want to discard them and continue?')) {
                    openReadOnlyPopup(newRowIndex, searchResults[newRowIndex].row, searchResults[newRowIndex].rowHash);
                }
            }
        }
    }

    function highlightRow(rowIndex) {
        const rows = editForm.querySelectorAll('tbody tr');
        rows.forEach((row, index) => {
            row.style.backgroundColor = index === rowIndex ? '#f2f2f2' : '';
        });
    }

    function enableEditing() {
        popupForm.querySelectorAll('textarea').forEach(textarea => {
            textarea.readOnly = false;
        });
        editButton.style.display = 'none';
        submitEditButton.style.display = 'block';
    }

    function submitEdit() {
        const formData = new FormData(popupForm);
        const updatedRow = {};
        headers.forEach(header => {
            updatedRow[header] = formData.get(header);
        });

        let originalRowHash = popup.dataset.md5;
        const updatedRowHash = CryptoJS.MD5(JSON.stringify(updatedRow)).toString();

        if (addedRowsHashes.has(originalRowHash)) {
            if (!addedRowsBySheet[currentFileName]) {
                addedRowsBySheet[currentFileName] = {};
            }
            if (!addedRowsBySheet[currentFileName][currentSheetName]) {
                addedRowsBySheet[currentFileName][currentSheetName] = {
                    headers: headers,
                    rows: []
                };
            }

            const existingIndex = addedRowsBySheet[currentFileName][currentSheetName].rows.findIndex(row => {
                return CryptoJS.MD5(JSON.stringify(row)).toString() === originalRowHash;
            });

            if (existingIndex !== -1) {
                addedRowsBySheet[currentFileName][currentSheetName].rows.splice(existingIndex, 1);
            }

            addedRowsBySheet[currentFileName][currentSheetName].rows.push(updatedRow);
            addedRowsHashes.delete(originalRowHash);
            addedRowsHashes.add(updatedRowHash);

            const initialIndex = initialAddedRows[currentFileName][currentSheetName].findIndex(row => {
                return CryptoJS.MD5(JSON.stringify(row)).toString() === originalRowHash;
            });

            if (initialIndex !== -1) {
                initialAddedRows[currentFileName][currentSheetName].splice(initialIndex, 1);
            }

            initialAddedRows[currentFileName][currentSheetName].push(updatedRow);
        } else {
            if (!modifiedRowsBySheet[currentFileName]) {
                modifiedRowsBySheet[currentFileName] = {};
            }
            if (!modifiedRowsBySheet[currentFileName][currentSheetName]) {
                modifiedRowsBySheet[currentFileName][currentSheetName] = {};
            }
            modifiedRowsBySheet[currentFileName][currentSheetName][updatedRowHash] = updatedRow;
        }

        updateSummaryDisplay();
        closePopup();
        showProgress('Change submitted.');
    }

    function updateSearchResultRow(rowHash, updatedRow) {
        const rowElement = document.querySelector(`tr[data-key="${rowHash}"]`);
        if (rowElement) {
            headers.forEach((header, index) => {
                const cell = rowElement.children[index + 1];
                cell.textContent = updatedRow[header].length > 100 ? updatedRow[header].substring(0, 100) + '...' : updatedRow[header];
            });
        }
    }

    function closePopup() {
        overlay.style.display = 'none';
        popup.style.display = 'none';
    }

    function getRowData(fileName, sheetName, rowIndex, row) {
        const originalRowHash = CryptoJS.MD5(JSON.stringify(row)).toString();
        if (modifiedRowHashes.has(originalRowHash)) {
            return modifiedRowsBySheet[fileName][sheetName][originalRowHash];
        }
        return row;
    }


    function handleEditEntry(fileName, sheetName, identifier, row, isModified = false) {
        currentRowIndex = identifier;
        const popup = document.getElementById('popup');
        if (isModified) {
            const tableToEdit = document.querySelector(`table[data-md5="${identifier}"]`);
            if (tableToEdit) {
                popup.dataset.md5 = tableToEdit.dataset.md5;
            }
        } else {
            popup.dataset.md5 = '';
        }
        openPopup(identifier, row, identifier, false);
        popupForm.onsubmit = (event) => {
            event.preventDefault();
            const formData = new FormData(popupForm);
            const updatedRow = {};
            headers.forEach(header => {
                updatedRow[header] = formData.get(header);
            });

            let originalRowHash = popup.dataset.md5;

            if (!addedRowsBySheet[fileName]) {
                addedRowsBySheet[fileName] = {};
            }
            if (!addedRowsBySheet[fileName][sheetName]) {
                addedRowsBySheet[fileName][sheetName] = {
                    headers: headers,
                    rows: []
                };
            }

            const existingIndex = addedRowsBySheet[fileName][sheetName].rows.findIndex(row => {
                return CryptoJS.MD5(JSON.stringify(row)).toString() === originalRowHash;
            });

            if (existingIndex !== -1) {
                addedRowsBySheet[fileName][sheetName].rows.splice(existingIndex, 1);
            }

            addedRowsBySheet[fileName][sheetName].rows.push(updatedRow);

            updateSummaryDisplay();
            closePopup();
            showProgress('Change submitted.');
        };
    }

    function handleDeleteEntry(fileName, sheetName, identifier, isModified = false) {
        if (isModified) {
            delete modifiedRowsBySheet[fileName][sheetName][identifier];
            if (Object.keys(modifiedRowsBySheet[fileName][sheetName]).length === 0) {
                delete modifiedRowsBySheet[fileName][sheetName];
            }
        } else {
            addedRowsBySheet[fileName][sheetName].rows.splice(identifier, 1);
            if (addedRowsBySheet[fileName][sheetName].rows.length === 0) {
                delete addedRowsBySheet[fileName][sheetName];
            }
        }

        updateSummaryDisplay();
        showProgress("Entry deleted successfully.");
    }

    function generateEmail() {
       try {
            const yamlBody = generateYaml(addedRowsBySheet, modifiedRowsBySheet);
            const summary = generateSummary(addedRowsBySheet, modifiedRowsBySheet);
            const allFiles = [...new Set([...Object.keys(addedRowsBySheet), ...Object.keys(modifiedRowsBySheet)])]; // Ensure unique file names
            const subject = encodeURIComponent(`Request for change: ${allFiles.join(', ')}`);

            // Remplacer les placeholders dans EMAIL_TEMPLATE
            const emailBody = EMAIL_TEMPLATE
                .replace('{FILES}', allFiles.join(', '))
                .replace('{SUMMARY}', summary)
                .replace('{DETAILS}', yamlBody);

            const body = encodeURIComponent(emailBody);
            const mailtoLink = `mailto:${EMAILS.join(',')}?cc=${CC_EMAILS.join(',')}&subject=${subject}&body=${body}`;
            window.location.href = mailtoLink;
            showProgress("Email draft prepared successfully.");
            resetButton.style.display = 'block';
       } catch (error) {
            showError("Failed to prepare the email: " + error.message);
       }
    }

    function generateEmail() {
    try {
        const yamlBody = generateYaml(addedRowsBySheet, modifiedRowsBySheet);
        const summary = generateSummary(addedRowsBySheet, modifiedRowsBySheet);
        const fileNames = [...new Set([
            ...Object.keys(addedRowsBySheet),
            ...Object.keys(modifiedRowsBySheet)
        ])];

        const subject = encodeURIComponent(`Request for change: ${fileNames.join(', ')}`);
        const body = EMAIL_TEMPLATE
            .replace('{FILES_LIST}', fileNames.join(', '))
            .replace('{SUMMARY}', summary)
            .replace('{MODIFICATIONS}', yamlBody);

        const mailtoLink = `mailto:${EMAILS.join(',')}?cc=${CC_EMAILS.join(',')}&subject=${subject}&body=${encodeURIComponent(body)}`;
        window.location.href = mailtoLink;
        showProgress("Email draft prepared successfully.");
        resetButton.style.display = 'block';
    } catch (error) {
        showError("Failed to prepare the email: " + error.message);
    }
}

    function generateYaml(addedRowsBySheet, modifiedRowsBySheet) {
        let yamlString = '';

        Object.keys(addedRowsBySheet).forEach(fileName => {
            Object.keys(addedRowsBySheet[fileName]).forEach(sheetName => {
                const { headers, rows } = addedRowsBySheet[fileName][sheetName];
                rows.forEach((row, index) => {
                    yamlString += `File: ${fileName}\nSheet: ${sheetName}\n`;
                    yamlString += `Proposed addition:\n`;
                    headers.forEach(header => {
                        yamlString += `  ${header}:\n    ${row[header].split('\n').join('\n    ')}\n\n`;
                    });
                    yamlString += `---\n`;
                });
            });
        });

        Object.keys(modifiedRowsBySheet).forEach(fileName => {
            Object.keys(modifiedRowsBySheet[fileName]).forEach(sheetName => {
                Object.keys(modifiedRowsBySheet[fileName][sheetName]).forEach(originalRowHash => {
                    const row = modifiedRowsBySheet[fileName][sheetName][originalRowHash];
                    yamlString += `File: ${fileName}\nSheet: ${sheetName} (Modified)\n`;
                    yamlString += `Proposed modification:\n`;
                    Object.keys(row).forEach(header => {
                        yamlString += `  ${header}:\n    ${row[header].split('\n').join('\n    ')}\n\n`;
                    });
                    yamlString += `---\n`;
                });
            });
        });

        return yamlString;
    }

    function generateYaml(addedRowsBySheet, modifiedRowsBySheet) {
    let yamlString = '';

    const drawBox = (content) => {
        const lines = content.split('\n');
        const width = Math.max(...lines.map(line => line.length)) + 2;
        const horizontalLine = '+' + '-'.repeat(width) + '+';
        const boxedContent = lines.map(line => `| ${line.padEnd(width - 1)}|`).join('\n');

        return `${horizontalLine}\n${boxedContent}\n${horizontalLine}`;
    };

    const formatRow = (row) => {
        return Object.entries(row)
            .map(([key, value]) => drawBox(`  ${key}:\n    ${String(value).split('\n').join('\n    ')}`))
            .join('\n');
    };

    Object.keys(addedRowsBySheet).forEach(fileName => {
        Object.keys(addedRowsBySheet[fileName]).forEach(sheetName => {
            const { headers, rows } = addedRowsBySheet[fileName][sheetName];
            rows.forEach(row => {
                const rowString = `File: ${fileName}\nSheet: ${sheetName}\nProposed addition:\n${formatRow(row)}`;
                yamlString += drawBox(rowString) + '\n';
            });
        });
    });

    Object.keys(modifiedRowsBySheet).forEach(fileName => {
        Object.keys(modifiedRowsBySheet[fileName]).forEach(sheetName => {
            Object.keys(modifiedRowsBySheet[fileName][sheetName]).forEach(rowHash => {
                const row = modifiedRowsBySheet[fileName][sheetName][rowHash];
                const rowString = `File: ${fileName}\nSheet: ${sheetName}\nProposed modification:\n${formatRow(row)}`;
                yamlString += drawBox(rowString) + '\n';
            });
        });
    });

    return yamlString.trim();
}


    function generateSummary(addedRowsBySheet, modifiedRowsBySheet) {
        let summary = '';

        Object.keys(addedRowsBySheet).forEach(fileName => {
            Object.keys(addedRowsBySheet[fileName]).forEach(sheetName => {
                const { rows } = addedRowsBySheet[fileName][sheetName];
                summary += `For file "${fileName}", for sheet "${sheetName}", ${rows.length} rows have been added.\n`;
            });
        });

        Object.keys(modifiedRowsBySheet).forEach(fileName => {
            Object.keys(modifiedRowsBySheet[fileName]).forEach(sheetName => {
                const rows = Object.keys(modifiedRowsBySheet[fileName][sheetName]).length;
                summary += `For file "${fileName}", for sheet "${sheetName}", ${rows} rows have been modified.\n`;
            });
        });

        return summary;
    }

    function normalizeString(str) {
        return str ? str.toString().normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase() : '';
    }

    function showError(message) {
        progressContainer.style.display = 'none';
        messageContainer.style.display = 'block';
        messageContainer.textContent = message;
        setTimeout(() => {
            messageContainer.textContent = '';
        }, 5000);
    }

    function showProgress(message) {
        progressMessage.textContent = message;
        progressContainer.style.display = 'block';
        messageContainer.style.display = 'block';
        messageContainer.textContent = message;
        setTimeout(() => {
            messageContainer.textContent = '';
        }, 5000);
    }

    function clearMessages() {
        progressMessage.textContent = '';
        progressContainer.style.display = 'none';
        messageContainer.textContent = '';
        messageContainer.style.display = 'none';
    }

    function resetInterface() {
    addedRowsBySheet = {};
    modifiedRowsBySheet = {};
    modifiedRowHashes = new Map();
    addedRowsHashes = new Set();
    initialAddedRows = {};
    clearMessages();
    summarySection.style.display = 'none';
    confirmDownloadButton.style.display = 'block';
    downloadLink.style.display = 'block';
    uploadSection.style.display = 'none';
    sheetSelectionSection.style.display = 'none';
    tabSection.style.display = 'none';
    resetButton.style.display = 'none';
    summarySeparator.style.display = 'none';

    // Clear localStorage
    localStorage.clear();

    // Clear previous search results
    clearSearchResults();

    // Reset Add form fields
    const addForm = document.getElementById('dynamicForm');
    addForm.reset();
    
    // Reset Search and Edit form fields
    const searchForm = document.getElementById('searchForm');
    searchForm.reset();

    // Hide additional sections
    document.getElementById('AddRow').style.display = 'none';
    document.getElementById('Search').style.display = 'none';
    results.style.display = 'none';

    // Hide loader
    loader.style.display = 'none';

    // Remove error messages if any
    progressContainer.style.display = 'none';
}

function clearSearchResults() {
    results.style.display = 'none';
    editForm.innerHTML = '';
}


    function resetInterfacePartial() {
        clearMessages();
        confirmDownloadButton.style.display = 'block';
        downloadLink.style.display = 'block';
        uploadSection.style.display = 'none';
        sheetSelectionSection.style.display = 'none';
        tabSection.style.display = 'none';
        document.getElementById('AddRow').style.display = 'none';
        document.getElementById('Search').style.display = 'none';
        searchInputs.innerHTML = '';
        editForm.innerHTML = '';
        results.style.display = 'none';
    }

    function clearSearchResults() {
        results.style.display = 'none';
        editForm.innerHTML = '';
    }


    function handleFormSubmit(event) {
    event.preventDefault();
    const formData = new FormData(dynamicForm);
    const row = {};
    let hasEmptyFields = false;
    headers.forEach(header => {
        const value = formData.get(header);
        if (!value) {
            hasEmptyFields = true;
        }
        row[header] = value;
    });

    if (hasEmptyFields) {
        showError("All fields must be filled out.");
        return;
    }

    row.addedByForm = true; // Marquer la ligne comme ajout√©e par le formulaire

    loadingIndicator.style.display = 'block';
    showProgress("Adding new row...");
    setTimeout(() => {
        try {
            const rowHash = CryptoJS.MD5(JSON.stringify(row)).toString();
            addedRowsHashes.add(rowHash);

            if (!addedRowsBySheet[currentFileName]) {
                addedRowsBySheet[currentFileName] = {};
            }
            if (!addedRowsBySheet[currentFileName][currentSheetName]) {
                addedRowsBySheet[currentFileName][currentSheetName] = {
                    headers: headers,
                    rows: []
                };
            }
            addedRowsBySheet[currentFileName][currentSheetName].rows.push(row);

            updateSummaryDisplay();
            showProgress("Row added successfully.");
            loadingIndicator.style.display = 'none';
        } catch (error) {
            showError("Failed to add the row: " + error.message);
            loadingIndicator.style.display = 'none';
        }
    }, 100);
}


function submitEdit() {
    const formData = new FormData(popupForm);
    const updatedRow = {};
    headers.forEach(header => {
        updatedRow[header] = formData.get(header);
    });

    let originalRowHash = popup.dataset.md5;
    const updatedRowHash = CryptoJS.MD5(JSON.stringify(updatedRow)).toString();

    // Conserver la marque ajout√©e par le formulaire
    const isAddedByForm = addedRowsHashes.has(originalRowHash);
    if (isAddedByForm) {
        updatedRow.addedByForm = true;
        addedRowsHashes.delete(originalRowHash);
        addedRowsHashes.add(updatedRowHash);

        const existingIndex = addedRowsBySheet[currentFileName][currentSheetName].rows.findIndex(row => {
            return CryptoJS.MD5(JSON.stringify(row)).toString() === originalRowHash;
        });

        if (existingIndex !== -1) {
            addedRowsBySheet[currentFileName][currentSheetName].rows[existingIndex] = updatedRow;
        } else {
            addedRowsBySheet[currentFileName][currentSheetName].rows.push(updatedRow);
        }
    } else {
        if (!modifiedRowsBySheet[currentFileName]) {
            modifiedRowsBySheet[currentFileName] = {};
        }
        if (!modifiedRowsBySheet[currentFileName][currentSheetName]) {
            modifiedRowsBySheet[currentFileName][currentSheetName] = {};
        }
        modifiedRowsBySheet[currentFileName][currentSheetName][updatedRowHash] = updatedRow;
    }

    updateSummaryDisplay();
    closePopup();
    showProgress('Change submitted.');
}

function handleEditEntry(fileName, sheetName, identifier, row, isModified = false) {
    currentRowIndex = identifier;
    const popup = document.getElementById('popup');
    const popupForm = document.getElementById('popupForm');

    // Effacez le formulaire du popup avant de le remplir
    popupForm.innerHTML = '';

    // Ouvrir le popup d'√©dition et remplir les donn√©es
    headers.forEach(header => {
        const label = document.createElement('label');
        label.textContent = header;
        const textarea = document.createElement('textarea');
        textarea.name = header;
        textarea.value = row[header] || '';
        popupForm.appendChild(label);
        popupForm.appendChild(textarea);
    });

    popup.dataset.md5 = CryptoJS.MD5(JSON.stringify(row)).toString();
    if (isModified) {
        popupForm.dataset.isModified = true;
    } else {
        popupForm.dataset.isModified = false;
    }

    // V√©rification pour s'assurer que les lignes ajout√©es par le formulaire ne sont pas d√©plac√©es vers Modifications
    if (row.addedByForm) {
        popup.dataset.addedByForm = true;
    } else {
        popup.dataset.addedByForm = false;
    }

    popup.style.display = 'block';
}


function submitEdit() {
    const formData = new FormData(popupForm);
    const updatedRow = {};
    headers.forEach(header => {
        updatedRow[header] = formData.get(header);
    });

    let originalRowHash = popup.dataset.md5;
    const updatedRowHash = CryptoJS.MD5(JSON.stringify(updatedRow)).toString();

    // Conserver la marque ajout√©e par le formulaire
    if (popup.dataset.addedByForm === 'true') {
        updatedRow.addedByForm = true;
        addedRowsHashes.delete(originalRowHash);
        addedRowsHashes.add(updatedRowHash);

        const existingIndex = addedRowsBySheet[currentFileName][currentSheetName].rows.findIndex(row => {
            return CryptoJS.MD5(JSON.stringify(row)).toString() === originalRowHash;
        });

        if (existingIndex !== -1) {
            addedRowsBySheet[currentFileName][currentSheetName].rows[existingIndex] = updatedRow;
        } else {
            addedRowsBySheet[currentFileName][currentSheetName].rows.push(updatedRow);
        }
    } else {
        if (!modifiedRowsBySheet[currentFileName]) {
            modifiedRowsBySheet[currentFileName] = {};
        }
        if (!modifiedRowsBySheet[currentFileName][currentSheetName]) {
            modifiedRowsBySheet[currentFileName][currentSheetName] = {};
        }
        modifiedRowsBySheet[currentFileName][currentSheetName][updatedRowHash] = updatedRow;
    }

    updateSummaryDisplay();
    closePopup();
    showProgress('Change submitted.');
}

function submitEdit() {
    const formData = new FormData(popupForm);
    const updatedRow = {};
    headers.forEach(header => {
        updatedRow[header] = formData.get(header) || ''; // Assurez-vous que chaque en-t√™te a une valeur par d√©faut
    });

    let originalRowHash = popup.dataset.md5;
    const updatedRowHash = CryptoJS.MD5(JSON.stringify(updatedRow)).toString();

    // Conserver la marque ajout√©e par le formulaire
    if (popup.dataset.addedByForm === 'true') {
        updatedRow.addedByForm = true;
        addedRowsHashes.delete(originalRowHash);
        addedRowsHashes.add(updatedRowHash);

        const existingIndex = addedRowsBySheet[currentFileName][currentSheetName].rows.findIndex(row => {
            return CryptoJS.MD5(JSON.stringify(row)).toString() === originalRowHash;
        });

        if (existingIndex !== -1) {
            addedRowsBySheet[currentFileName][currentSheetName].rows[existingIndex] = updatedRow;
        } else {
            addedRowsBySheet[currentFileName][currentSheetName].rows.push(updatedRow);
        }
    } else {
        if (!modifiedRowsBySheet[currentFileName]) {
            modifiedRowsBySheet[currentFileName] = {};
        }
        if (!modifiedRowsBySheet[currentFileName][currentSheetName]) {
            modifiedRowsBySheet[currentFileName][currentSheetName] = {};
        }
        modifiedRowsBySheet[currentFileName][currentSheetName][updatedRowHash] = updatedRow;
    }

    updateSummaryDisplay();
    closePopup();
    showProgress('Change submitted.');
}

function handleEditEntry(fileName, sheetName, identifier, row, isModified = false) {
    currentRowIndex = identifier;
    const popup = document.getElementById('popup');
    const popupForm = document.getElementById('popupForm');

    // Effacez le formulaire du popup avant de le remplir
    popupForm.innerHTML = '';

    // Ouvrir le popup d'√©dition et remplir les donn√©es
    headers.forEach(header => {
        const label = document.createElement('label');
        label.textContent = header;
        const textarea = document.createElement('textarea');
        textarea.name = header;
        textarea.value = row[header] || '';
        popupForm.appendChild(label);
        popupForm.appendChild(textarea);
    });

    popup.dataset.md5 = CryptoJS.MD5(JSON.stringify(row)).toString();
    if (isModified) {
        popupForm.dataset.isModified = true;
    } else {
        popupForm.dataset.isModified = false;
    }

    // V√©rification pour s'assurer que les lignes ajout√©es par le formulaire ne sont pas d√©plac√©es vers Modifications
    if (row.addedByForm) {
        popup.dataset.addedByForm = true;
    } else {
        popup.dataset.addedByForm = false;
    }

    popup.style.display = 'block';
}

//OKOKOKOKOK

function submitEdit() {
    const formData = new FormData(popupForm);
    const updatedRow = {};
    headers.forEach(header => {
        updatedRow[header] = formData.get(header) || ''; // Assurez-vous que chaque en-t√™te a une valeur par d√©faut
    });

    let originalRowHash = popup.dataset.md5;
    const updatedRowHash = CryptoJS.MD5(JSON.stringify(updatedRow)).toString();

    // Conserver la marque ajout√©e par le formulaire
    if (popup.dataset.addedByForm === 'true') {
        updatedRow.addedByForm = true;
        addedRowsHashes.delete(originalRowHash);
        addedRowsHashes.add(updatedRowHash);

        const existingIndex = addedRowsBySheet[currentFileName][currentSheetName].rows.findIndex(row => {
            return CryptoJS.MD5(JSON.stringify(row)).toString() === originalRowHash;
        });

        if (existingIndex !== -1) {
            // Supprimer l'entr√©e initiale
            addedRowsBySheet[currentFileName][currentSheetName].rows.splice(existingIndex, 1);
        }
        
        // Ajouter la ligne modifi√©e comme nouvelle entr√©e
        addedRowsBySheet[currentFileName][currentSheetName].rows.push(updatedRow);
    } else {
        if (!modifiedRowsBySheet[currentFileName]) {
            modifiedRowsBySheet[currentFileName] = {};
        }
        if (!modifiedRowsBySheet[currentFileName][currentSheetName]) {
            modifiedRowsBySheet[currentFileName][currentSheetName] = {};
        }
        modifiedRowsBySheet[currentFileName][currentSheetName][updatedRowHash] = updatedRow;
    }

    updateSummaryDisplay();
    closePopup();
    showProgress('Change submitted.');
}


//Mhmmmmmmmm

function handleFormSubmit(event) {
    event.preventDefault();
    const formData = new FormData(dynamicForm);
    const row = {};
    let hasEmptyFields = false;
    headers.forEach(header => {
        const value = formData.get(header);
        if (!value) {
            hasEmptyFields = true;
        }
        row[header] = value;
    });

    if (hasEmptyFields) {
        showError("All fields must be filled out.");
        return;
    }

    row.id = generateUniqueId(); // G√©n√©rer un identifiant unique
    row.addedByForm = true; // Marquer la ligne comme ajout√©e par le formulaire

    loadingIndicator.style.display = 'block';
    showProgress("Adding new row...");
    setTimeout(() => {
        try {
            const rowHash = CryptoJS.MD5(JSON.stringify(row)).toString();
            addedRowsHashes.add(rowHash);

            if (!addedRowsBySheet[currentFileName]) {
                addedRowsBySheet[currentFileName] = {};
            }
            if (!addedRowsBySheet[currentFileName][currentSheetName]) {
                addedRowsBySheet[currentFileName][currentSheetName] = {
                    headers: headers,
                    rows: []
                };
            }
            addedRowsBySheet[currentFileName][currentSheetName].rows.push(row);

            updateSummaryDisplay();
            showProgress("Row added successfully.");
            loadingIndicator.style.display = 'none';
        } catch (error) {
            showError("Failed to add the row: " + error.message);
            loadingIndicator.style.display = 'none';
        }
    }, 100);
}

function generateUniqueId() {
    return 'id-' + Math.random().toString(36).substr(2, 16);
}

function submitEdit() {
    const formData = new FormData(popupForm);
    const updatedRow = {};
    headers.forEach(header => {
        updatedRow[header] = formData.get(header) || ''; // Assurez-vous que chaque en-t√™te a une valeur par d√©faut
    });

    let originalRowId = popup.dataset.id;
    const updatedRowHash = CryptoJS.MD5(JSON.stringify(updatedRow)).toString();

    // Conserver la marque ajout√©e par le formulaire
    if (popup.dataset.addedByForm === 'true') {
        updatedRow.addedByForm = true;
        updatedRow.id = originalRowId;
        addedRowsHashes.delete(originalRowId);
        addedRowsHashes.add(updatedRowHash);

        const existingIndex = addedRowsBySheet[currentFileName][currentSheetName].rows.findIndex(row => {
            return row.id === originalRowId;
        });

        if (existingIndex !== -1) {
            // Supprimer l'entr√©e initiale
            addedRowsBySheet[currentFileName][currentSheetName].rows.splice(existingIndex, 1);
        }
        
        // Ajouter la ligne modifi√©e comme nouvelle entr√©e
        addedRowsBySheet[currentFileName][currentSheetName].rows.push(updatedRow);
    } else {
        if (!modifiedRowsBySheet[currentFileName]) {
            modifiedRowsBySheet[currentFileName] = {};
        }
        if (!modifiedRowsBySheet[currentFileName][currentSheetName]) {
            modifiedRowsBySheet[currentFileName][currentSheetName] = {};
        }
        updatedRow.id = originalRowId;
        modifiedRowsBySheet[currentFileName][currentSheetName][updatedRowHash] = updatedRow;
    }

    updateSummaryDisplay();
    closePopup();
    showProgress('Change submitted.');
}


function handleEditEntry(fileName, sheetName, identifier, row, isModified = false) {
    currentRowIndex = identifier;
    const popup = document.getElementById('popup');
    const popupForm = document.getElementById('popupForm');

    // Effacez le formulaire du popup avant de le remplir
    popupForm.innerHTML = '';

    // Ouvrir le popup d'√©dition et remplir les donn√©es
    headers.forEach(header => {
        const label = document.createElement('label');
        label.textContent = header;
        const textarea = document.createElement('textarea');
        textarea.name = header;
        textarea.value = row[header] || '';
        popupForm.appendChild(label);
        popupForm.appendChild(textarea);
    });

    popup.dataset.id = row.id;
    popup.dataset.md5 = CryptoJS.MD5(JSON.stringify(row)).toString();
    if (isModified) {
        popupForm.dataset.isModified = true;
    } else {
        popupForm.dataset.isModified = false;
    }

    // V√©rification pour s'assurer que les lignes ajout√©es par le formulaire ne sont pas d√©plac√©es vers Modifications
    if (row.addedByForm) {
        popup.dataset.addedByForm = true;
    } else {
        popup.dataset.addedByForm = false;
    }

    popup.style.display = 'block';
}

/////bonbonbonbonbon pasmalmalmalmal

function updateSummaryDisplay() {
    addedRows.innerHTML = '';
    modifiedRows.innerHTML = '';

    let hasAdditions = false;
    let hasModifications = false;

    Object.keys(addedRowsBySheet).forEach(fileName => {
        Object.keys(addedRowsBySheet[fileName]).forEach(sheetName => {
            const { headers, rows } = addedRowsBySheet[fileName][sheetName] || {};
            if (headers && rows) {
                rows.forEach((row, index) => {
                    const table = document.createElement('table');
                    table.classList.add('added-row-table');
                    const thead = document.createElement('thead');
                    const headerRow = document.createElement('tr');
                    const thFileName = document.createElement('th');
                    thFileName.colSpan = headers.length;
                    thFileName.textContent = `File: ${fileName}, Sheet: ${sheetName}`;
                    headerRow.appendChild(thFileName);
                    thead.appendChild(headerRow);
                    const headerRow2 = document.createElement('tr');
                    headers && headers.forEach(header => {
                        const th = document.createElement('th');
                        th.textContent = header;
                        headerRow2.appendChild(th);
                    });
                    thead.appendChild(headerRow2);
                    table.appendChild(thead);
                    const tbody = document.createElement('tbody');
                    const dataRow = document.createElement('tr');
                    headers && headers.forEach(header => {
                        const td = document.createElement('td');
                        td.textContent = row[header];
                        dataRow.appendChild(td);
                    });
                    tbody.appendChild(dataRow);
                    table.appendChild(tbody);
                    const editButton = document.createElement('button');
                    editButton.textContent = '‚úé';
                    editButton.classList.add('edit-btn');
                    editButton.addEventListener('click', () => handleEditEntry(fileName, sheetName, index, row));
                    const deleteButton = document.createElement('button');
                    deleteButton.textContent = '‚úñ';
                    deleteButton.classList.add('delete-btn');
                    deleteButton.addEventListener('click', () => handleDeleteEntry(fileName, sheetName, index));
                    table.appendChild(deleteButton);
                    table.appendChild(editButton);
                    addedRows.appendChild(table);
                });
                hasAdditions = true;
            }
        });
    });

    Object.keys(modifiedRowsBySheet).forEach(fileName => {
        Object.keys(modifiedRowsBySheet[fileName]).forEach(sheetName => {
            const rowsObj = modifiedRowsBySheet[fileName][sheetName];
            const headers = addedRowsBySheet[fileName] ?  addedRowsBySheet[fileName][sheetName] && addedRowsBySheet[fileName][sheetName].headers : [];
            Object.keys(rowsObj).forEach(rowHash => {
                const row = rowsObj[rowHash];
                if (!row.addedByForm) {
                    const table = document.createElement('table');
                    table.classList.add('modified-row-table');
                    const thead = document.createElement('thead');
                    const headerRow = document.createElement('tr');
                    const thFileName = document.createElement('th');
                    thFileName.colSpan = headers && headers.length;
                    thFileName.textContent = `File: ${fileName}, Sheet: ${sheetName} (Modified)`;
                    headerRow.appendChild(thFileName);
                    thead.appendChild(headerRow);
                    const headerRow2 = document.createElement('tr');
                    headers && headers.forEach(header => {
                        const th = document.createElement('th');
                        th.textContent = header;
                        headerRow2.appendChild(th);
                    });
                    thead.appendChild(headerRow2);
                    table.appendChild(thead);
                    const tbody = document.createElement('tbody');
                    const dataRow = document.createElement('tr');
                    headers && headers.forEach(header => {
                        const td = document.createElement('td');
                        td.textContent = row[header];
                        dataRow.appendChild(td);
                    });
                    tbody.appendChild(dataRow);
                    table.appendChild(tbody);
                    const editButton = document.createElement('button');
                    editButton.textContent = '‚úé';
                    editButton.classList.add('edit-btn');
                    editButton.addEventListener('click', () => handleEditEntry(fileName, sheetName, rowHash, row, true));
                    const deleteButton = document.createElement('button');
                    deleteButton.textContent = '‚úñ';
                    deleteButton.classList.add('delete-btn');
                    deleteButton.addEventListener('click', () => handleDeleteEntry(fileName, sheetName, rowHash, true));
                    table.appendChild(deleteButton);
                    table.appendChild(editButton);
                    modifiedRows.appendChild(table);
                    hasModifications = true;
                }
            });
        });
    });

    // Toujours afficher les conteneurs
    addedRowsContainer.style.display = 'block';
    modifiedRowsContainer.style.display = 'block';
    summarySection.style.display = hasAdditions || hasModifications ? 'block' : 'none';
    summarySeparator.style.display = hasAdditions || hasModifications ? 'block' : 'none';



     // Enregistrer les donn√©es dans le local storage
    localStorage.setItem('addedRowsBySheet', JSON.stringify(addedRowsBySheet));
    localStorage.setItem('modifiedRowsBySheet', JSON.stringify(modifiedRowsBySheet));

}

function loadFromLocalStorage() {
    const addedRowsData = localStorage.getItem('addedRowsBySheet');
    const modifiedRowsData = localStorage.getItem('modifiedRowsBySheet');
    if (addedRowsData) {
        addedRowsBySheet = JSON.parse(addedRowsData);
    }
    if (modifiedRowsData) {
        modifiedRowsBySheet = JSON.parse(modifiedRowsData);
    }
    updateSummaryDisplay(); // Mettre √† jour l'affichage du r√©sum√©
}



document.addEventListener('DOMContentLoaded', () => {
    const dynamicForm = document.getElementById('dynamicForm');
    const popupForm = document.getElementById('popupForm');

    dynamicForm.addEventListener('submit', handleFormSubmit);
    popupForm.addEventListener('submit', (event) => {
        event.preventDefault();
        submitEdit();
    });
});

function searchRows(query, restrict) {
    const worksheet = workbook.Sheets[currentSheetName];
    const range = XLSX.utils.decode_range(worksheet['!ref']);
    const results = [];

    for (let rowNum = range.s.r + 1; rowNum <= range.e.r; rowNum++) {
        let rowMatch = true;
        const row = {};

        headers.forEach((header, index) => {
            const cell = worksheet[XLSX.utils.encode_cell({ r: rowNum, c: index })];
            const cellValue = cell ? normalizeString(cell.v) : '';
            const queryValue = query[header] || '';

            if (queryValue) {
                const queryParts = queryValue.split(/(&&|\|\||!)/).map(part => part.trim());
                let operator = null;

                for (let i = 0; i < queryParts.length; i++) {
                    const part = queryParts[i];
                    if (part === '&&') {
                        operator = 'AND';
                    } else if (part === '||') {
                        operator = 'OR';
                    } else if (part === '!') {
                        operator = 'NOT';
                    } else {
                        let match;
                        if (operator === 'NOT') {
                            match = !cellValue.includes(part);
                            operator = null;
                        } else {
                            match = cellValue.includes(part);
                        }

                        if (operator === 'AND' && !match) {
                            rowMatch = false;
                        } else if (operator === 'OR' && match) {
                            rowMatch = true;
                        } else if (operator === null) {
                            rowMatch = match;
                        }
                    }
                }
            }

            row[header] = cell ? cell.v : '';
        });

        if (rowMatch) {
            const rowHash = CryptoJS.MD5(JSON.stringify(row)).toString();
            results.push({ rowNum, row, rowHash });
        }

        if (rowNum % 10 === 0) {
            showProgress(`Processing row ${rowNum}...`);
        }
    }

    return results;
}

function openPopup(rowNum, row, rowHash, isReadOnly = true) {
    popupForm.innerHTML = '';
    const existingEntry = modifiedRowsBySheet[currentFileName]?.[currentSheetName]?.[rowHash];
    const displayRow = existingEntry || row;
    headers.forEach(header => {
        const label = document.createElement('label');
        label.textContent = header;
        const textarea = document.createElement('textarea');
        textarea.name = header;
        textarea.value = displayRow[header] || '';
        textarea.readOnly = isReadOnly;
        popupForm.appendChild(label);
        popupForm.appendChild(textarea);
    });
    popup.dataset.md5 = rowHash;

    editButton.style.display = isReadOnly ? 'block' : 'none';
    submitEditButton.style.display = isReadOnly ? 'none' : 'block';
    prevRowButton.style.display = currentRowIndex > 0 ? 'inline-block' : 'none';
    nextRowButton.style.display = currentRowIndex < searchResults.length - 1 ? 'inline-block' : 'none';
    okButton.style.display = 'block';
    overlay.style.display = 'block';
    popup.style.display = 'block';
    highlightRow(currentRowIndex);
}

function enableEditing() {
    popupForm.querySelectorAll('textarea').forEach(textarea => {
        textarea.readOnly = false;
    });
    editButton.style.display = 'none';
    submitEditButton.style.display = 'block';
}

function updateOkButtonText(isEditing) {
    if (isEditing) {
        okButton.textContent = 'Cancel';
    } else {
        okButton.textContent = 'Close';
    }
}

function openPopup(rowNum, row, rowHash, isReadOnly = true) {
    popupForm.innerHTML = '';
    const existingEntry = modifiedRowsBySheet[currentFileName]?.[currentSheetName]?.[rowHash];
    const displayRow = existingEntry || row;
    headers.forEach(header => {
        const label = document.createElement('label');
        label.textContent = header;
        const textarea = document.createElement('textarea');
        textarea.name = header;
        textarea.value = displayRow[header] || '';
        textarea.readOnly = isReadOnly;
        popupForm.appendChild(label);
        popupForm.appendChild(textarea);
    });
    popup.dataset.md5 = rowHash;

    editButton.style.display = isReadOnly ? 'block' : 'none';
    submitEditButton.style.display = isReadOnly ? 'none' : 'block';
    updateOkButtonText(!isReadOnly);
    prevRowButton.style.display = currentRowIndex > 0 ? 'inline-block' : 'none';
    nextRowButton.style.display = currentRowIndex < searchResults.length - 1 ? 'inline-block' : 'none';
    okButton.style.display = 'block';
    overlay.style.display = 'block';
    popup.style.display = 'block';
    highlightRow(currentRowIndex);
}

function enableEditing() {
    popupForm.querySelectorAll('textarea').forEach(textarea => {
        textarea.readOnly = false;
    });
    editButton.style.display = 'none';
    submitEditButton.style.display = 'block';
    updateOkButtonText(true);
}

okButton.addEventListener('click', () => {
    if (okButton.textContent === 'Cancel') {
       exitEditingMode();
    } else {
        closePopup();
    }
});

function exitEditingMode() {
    popupForm.querySelectorAll('textarea').forEach(textarea => {
        textarea.readOnly = true;
    });
    editButton.style.display = 'block';
    submitEditButton.style.display = 'none';
    updateOkButtonText(false);
}

    const searchModeButton = document.getElementById('searchMode');
    let searchMode = 'AND';

    searchModeButton.addEventListener('click', () => {
        if (searchMode === 'AND') {
            searchMode = 'OR';
            searchModeButton.textContent = 'OR';
        } else {
            searchMode = 'AND';
            searchModeButton.textContent = 'AND';
        }
    });

    searchForm.addEventListener('submit', handleSearch);

    function handleSearch(event) {
        event.preventDefault();
        searchLoader.style.display = 'block';
        const formData = new FormData(searchForm);
        const query = {};
        let hasAnyKeyword = false;
        headers.forEach(header => {
            const value = normalizeString(formData.get(header));
            if (value) {
                query[header] = value;
                hasAnyKeyword = true;
            }
        });

        if (!hasAnyKeyword) {
            showError("Please enter at least one keyword.");
            searchLoader.style.display = 'none';
            return;
        }

        showProgress("Starting search...");
        try {
            searchResults = searchRows(query, searchMode === 'AND');
            displayResults(searchResults);
        } catch (error) {
            showError("Failed to search: " + error.message);
        } finally {
            searchLoader.style.display = 'none';
        }
    }

    function searchRows(query, restrict) {
        const worksheet = workbook.Sheets[currentSheetName];
        const range = XLSX.utils.decode_range(worksheet['!ref']);
        const results = [];

        for (let rowNum = range.s.r + 1; rowNum <= range.e.r; rowNum++) {
            let rowMatch = restrict;
            const row = {};

            headers.forEach((header, index) => {
                const cell = worksheet[XLSX.utils.encode_cell({ r: rowNum, c: index })];
                const cellValue = cell ? normalizeString(cell.v) : '';
                const queryValue = query[header] || '';

                if (queryValue) {
                    const queryParts = queryValue.split(/(&&|\|\||!)/).map(part => part.trim());
                    let operator = null;

                    for (let i = 0; i < queryParts.length; i++) {
                        const part = queryParts[i];
                        if (part === '&&') {
                            operator = 'AND';
                        } else if (part === '||') {
                            operator = 'OR';
                        } else if (part === '!') {
                            operator = 'NOT';
                        } else {
                            let match;
                            if (operator === 'NOT') {
                                match = !cellValue.includes(part);
                                operator = null;
                            } else {
                                match = cellValue.includes(part);
                            }

                            if (restrict) {
                                if (operator === 'AND' && !match) {
                                    rowMatch = false;
                                } else if (operator === 'OR' && match) {
                                    rowMatch = true;
                                } else if (operator === null) {
                                    rowMatch = rowMatch && match;
                                }
                            } else {
                                if (operator === 'AND' && !match) {
                                    rowMatch = false;
                                } else if (operator === 'OR' && match) {
                                    rowMatch = true;
                                } else if (operator === null) {
                                    rowMatch = rowMatch || match;
                                }
                            }
                        }
                    }
                }

                row[header] = cell ? cell.v : '';
            });

            if (rowMatch) {
                const rowHash = CryptoJS.MD5(JSON.stringify(row)).toString();
                results.push({ rowNum, row, rowHash });
            }

            if (rowNum % 10 === 0) {
                showProgress(`Processing row ${rowNum}...`);
            }
        }

        return results;
    }

    function generateEmail() {
        try {
            const yamlBody = generateYaml(addedRowsBySheet, modifiedRowsBySheet);
            const summary = generateSummary(addedRowsBySheet, modifiedRowsBySheet);
            const allFiles = [...new Set([...Object.keys(addedRowsBySheet), ...Object.keys(modifiedRowsBySheet)])]; // Ensure unique file names
            const subject = encodeURIComponent(`Request for change: ${allFiles.join(', ')}`);

            // Remplacer les placeholders dans EMAIL_TEMPLATE
            const emailBody = EMAIL_TEMPLATE
                .replace('{FILES_LIST}', allFiles.join(', '))
                .replace('{SUMMARY}', summary)
                .replace('{MODIFICATIONS}', yamlBody);

            const body = encodeURIComponent(emailBody);
            const mailtoLink = `mailto:${EMAILS.join(',')}?cc=${CC_EMAILS.join(',')}&subject=${subject}&body=${body}`;
            window.location.href = mailtoLink;

            // Afficher le texte g√©n√©r√© dans la balise <pre>
            emailContent.textContent = emailBody;
            emailContentContainer.style.display = 'block';

            showProgress("Email draft prepared successfully.");
            resetButton.style.display = 'block';
            closeProgressButton.style.display = 'block';
        } catch (error) {
            showError("Failed to prepare the email: " + error.message);
        }
    }

function copyEmailContent() {
    const text = emailContent.textContent;
    navigator.clipboard.writeText(text).then(() => {
        const copyButton = document.getElementById('copyEmailContent');
        copyButton.textContent = 'Copied';
        setTimeout(() => {
            copyButton.textContent = 'Copy';
        }, 5000);
    }).catch(err => {
        showError('Failed to copy text: ' + err);
    });
}

    // Autres fonctions

    function generateYaml(addedRowsBySheet, modifiedRowsBySheet) {
        let yamlString = '';

        Object.keys(addedRowsBySheet).forEach(fileName => {
            Object.keys(addedRowsBySheet[fileName]).forEach(sheetName => {
                const { headers, rows } = addedRowsBySheet[fileName][sheetName];
                rows.forEach(row => {
                    yamlString += drawBox(`File: ${fileName}\nSheet: ${sheetName}\n${formatRow(row)}`) + '\n\n'; // Ajout d'un saut de ligne
                });
            });
        });

        Object.keys(modifiedRowsBySheet).forEach(fileName => {
            Object.keys(modifiedRowsBySheet[fileName]).forEach(sheetName => {
                Object.values(modifiedRowsBySheet[fileName][sheetName]).forEach(row => {
                    yamlString += drawBox(`File: ${fileName}\nSheet: ${sheetName}\n${formatRow(row)}`) + '\n\n'; // Ajout d'un saut de ligne
                });
            });
        });

        return yamlString;
    }

    function formatRow(row) {
        return Object.entries(row)
            .map(([key, value]) => drawBox(`  ${key}:\n    ${String(value).split('\n').join('\n    ')}`))
            .join('\n');
    }

    function drawBox(content) {
        const lines = content.split('\n');
        const width = Math.max(...lines.map(line => line.length));
        const horizontalBorder = `+${'-'.repeat(width + 2)}+`;

        const formattedLines = lines.map(line => `| ${line.padEnd(width)} |`);

        return [horizontalBorder, ...formattedLines, horizontalBorder].join('\n');
    }

    // Event listener for search filter input
    searchFilterInput.addEventListener('input', () => {
        const filter = searchFilterInput.value.toLowerCase();
        const rows = searchInputs.querySelectorAll('tr');
        rows.forEach(row => {
            const label = row.querySelector('label').textContent.toLowerCase();
            if (label.includes(filter)) {
                row.style.display = '';
            } else {
                row.style.display = 'none';
            }
        });
    });
    
    // Event listener for add row filter input
    addRowFilterInput.addEventListener('input', () => {
        const filter = addRowFilterInput.value.toLowerCase();
        const fields = dynamicForm.querySelectorAll('label, textarea');
        fields.forEach((field, index) => {
            if (index % 2 === 0) {
                const label = field.textContent.toLowerCase();
                if (label.includes(filter)) {
                    field.style.display = '';
                    fields[index + 1].style.display = '';
                } else {
                    field.style.display = 'none';
                    fields[index + 1].style.display = 'none';
                }
            }
        });
    });

    dynamicForm.addEventListener('submit', (event) => {
        event.preventDefault();
        const formData = new FormData(dynamicForm);
        const row = {};
        let hasEmptyFields = false;
        let filtered = addRowFilterInput.value.trim() !== '';

        headers.forEach(header => {
            const value = formData.get(header);
            if (!value) {
                hasEmptyFields = true;
            }
            row[header] = value;
        });

        if (hasEmptyFields) {
            let message = "All fields must be filled out.";
            if (filtered) {
                message += " Please clear the field filter to see which fields need to be completed.";
            }
            showError(message);
            return;
        }

        loadingIndicator.style.display = 'block';
        showProgress("Adding new row...");
        setTimeout(() => {
            try {
                const rowHash = CryptoJS.MD5(JSON.stringify(row)).toString();
                addedRowsHashes.add(rowHash);

                if (!addedRowsBySheet[currentFileName]) {
                    addedRowsBySheet[currentFileName] = {};
                }
                if (!addedRowsBySheet[currentFileName][currentSheetName]) {
                    addedRowsBySheet[currentFileName][currentSheetName] = {
                        headers: headers,
                        rows: []
                    };
                }
                addedRowsBySheet[currentFileName][currentSheetName].rows.push(row);

                updateSummaryDisplay();
                showProgress("Row added successfully.");
                loadingIndicator.style.display = 'none';
            } catch (error) {
                showError("Failed to add the row: " + error.message);
                loadingIndicator.style.display = 'none';
            }
        }, 100);
    });

function handleSearch(event) {
    event.preventDefault();
    showProgress("Starting search...");
    searchLoader.style.display = 'block';

    setTimeout(() => {
        const formData = new FormData(searchForm);
        const query = {};
        headers.forEach(header => {
            const value = normalizeString(formData.get(header));
            if (value) {
                query[header] = value;
            }
        });

        try {
            searchResults = searchRows(query, restrictSearch.checked);
            displayResults(searchResults);
        } catch (error) {
            showError("Failed to search: " + error.message);
        } finally {
            searchLoader.style.display = 'none';
        }
    }, 500); // D√©lai pour simuler le chargement
}

function searchRows(query, restrict) {
    const worksheet = workbook.Sheets[currentSheetName];
    const range = XLSX.utils.decode_range(worksheet['!ref']);
    const results = [];
    const hasQuery = Object.keys(query).length > 0;

    for (let rowNum = range.s.r + 1; rowNum <= range.e.r; rowNum++) {
        let rowMatch = !hasQuery; // Si aucun filtre n'est renseign√©, affiche toutes les lignes
        const row = {};

        headers.forEach((header, index) => {
            const cell = worksheet[XLSX.utils.encode_cell({ r: rowNum, c: index })];
            const cellValue = cell ? normalizeString(cell.v) : '';
            const queryValue = query[header] || '';

            if (queryValue) {
                const queryParts = queryValue.split(/(&&|\|\||!)/).map(part => part.trim());
                let operator = null;

                for (let i = 0; i < queryParts.length; i++) {
                    const part = queryParts[i];
                    if (part === '&&') {
                        operator = 'AND';
                    } else if (part === '||') {
                        operator = 'OR';
                    } else if (part === '!') {
                        operator = 'NOT';
                    } else {
                        let match;
                        if (operator === 'NOT') {
                            match = !cellValue.includes(part);
                            operator = null;
                        } else {
                            match = cellValue.includes(part);
                        }

                        if (operator === 'AND' && !match) {
                            rowMatch = false;
                        } else if (operator === 'OR' && match) {
                            rowMatch = true;
                        } else if (operator === null) {
                            rowMatch = match;
                        }
                    }
                }
            }

            row[header] = cell ? cell.v : '';
        });

        if (rowMatch) {
            const rowHash = CryptoJS.MD5(JSON.stringify(row)).toString();
            results.push({ rowNum, row, rowHash });
        }
    }

    return results;
}

function showError(message) {
    progressMessage.textContent = message;
    progressContainer.style.display = 'block';
    progressContainer.classList.add('error');
    setTimeout(() => {
        progressContainer.style.display = 'none';
        progressContainer.classList.remove('error');
    }, 5000); // Affiche le message pendant 5 secondes
}

document.addEventListener('DOMContentLoaded', () => {
    const tablinks = document.getElementsByClassName("tablinks");
    if (tablinks.length > 0) {
        tablinks[0].click();
    }
});



});

function openTab(evt, tabName) {
    var i, tabcontent, tablinks;
    tabcontent = document.getElementsByClassName("tabcontent");
    for (i = 0; i < tabcontent.length; i++) {
        tabcontent[i].style.display = "none";
    }
    tablinks = document.getElementsByClassName("tablinks");
    for (i = 0; i < tablinks.length; i++) {
        tablinks[i].className = tablinks[i].className.replace(" active", "");
    }
    document.getElementById(tabName).style.display = "block";
    evt.currentTarget.className += " active";
}




    </script>
</body>
</html>
